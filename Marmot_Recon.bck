#include <stdio.h>
#include <stdlib.h>
//#include <io.h>
//#include <mmsystem.h> //播放音乐库函数
#include <string.h>
#include <time.h> //随机数
#include <stdbool.h> //C语言中使用bool需要先定义这个头文件
#include <math.h>
#include <unistd.h> //linux下getcwd()用来获取这个文件的路径


#include <sys/stat.h>
#include <sys/types.h>
	//char savepath[256];
char *context_current[2] = {"You", "Enemy"};
char context[3][50];

/*
1. 可佩戴物品，增加部分属性
2. 技能和物品槽天赋等级越高 技能技能越强，物品槽更多
3. 特殊地点：锻造室，物品交换仪
4. 地图分区，进入其他区域需要满足一定的条件

*/

/*
    0黑色，1蓝色，2 绿色，3 浅绿色，4红色，5紫色，6黄色，7白色，8灰色，9浅蓝，
    A浅绿，B浅蓝色，C浅红色，D浅紫色，E浅黄色，F亮白色
    system("COLOR 背景颜色+文字颜色");
*/

struct all_items
{
    char item_name[20];
    struct all_property_items
    {
        char ID[22];
        char type[20];
        char site[20];
    } property;
} all[15];

struct own_items
{
    char item_name[20];
    int amount;
    struct own_property_items
    {
        char ID[22];
        char type[20];
        char site[20];
    } property;
} capacity[15], temp;

struct game_settings
{
    char name[25];
    int status;
} sets[4];

struct character
{
    int money;
    int level;
    int damage;
    int energy;
    int blood;

} chara;

struct pets
{
    int num;
    int damage;
    int pet_level;
} pet[3];

bool show_advanced_setting = false;
int j_all = 0, j_capacity = 0, j_settings = 0;

/************************************************/

char *s_gets(char *st, int n)
{
    char *ret_val;
    int i = 0;
    ret_val = fgets(st, n, stdin);
    if (ret_val)
    {
        while (st[i] != '\0' && st[i] != '\n')
            i++;
        if (st[i] == '\n')
            st[i] = '\0';
        else
            while (getchar() != '\n')
                continue;
    }
    return ret_val;
}

/************************************************/

int enter_counter(FILE *fp)
{
    char ch;
    int j = 0; //一定记得初始化j的值
    while ((ch = fgetc(fp)) != EOF)
    {
        if (ch == '\n')
            j++;
    }
    rewind(fp);
    return j;
}
/************************************************/

char differ_platform_getchar()
{
	char c;
#ifdef WIN32
	c = getch();
	putchar(c);
#else
	char ch[2];
	strcpy(ch, s_gets(ch,2));
	//ch = s_gets(ch,2);
	c = ch[0];
#endif
	return c;
	
}

/************************************************/

void settings_get()
{
    FILE *fp;
    fp = fopen("settings.txt", "r");
    j_settings = enter_counter(fp);
    for (int i = 0; i < j_settings; i++)
        fscanf(fp, "%s %d", sets[i].name, &sets[i].status);
    fclose(fp);
}

/************************************************/

void settings_view()
{
    putchar(10);
    int i, j, max;
    max = strlen(sets[0].name);
    for (i = 1; i < j_settings; i++)
        if (strlen(sets[i].name) > max)
            max = strlen(sets[i].name);
    printf("\tNO.\tSETTINGS");
    for (i = 0; i < max - (strlen("SETTINGS") - 5); i++)
        printf(" ");
    printf("STATUS\n\n");
    for (i = 0; i < j_settings; i++)
    {
        printf("\t%d\t%s", i + 1, sets[i].name);
        for (j = 0; j < max - strlen(sets[i].name) + 5; j++) //这里 +8 是因为 SETTINGS 的长度为 8, (想了想还是改成 +5 会好很多)
            printf(" ");
        if (sets[i].status == 1)
            puts("True");
        else
            puts("False");
    }
    putchar(10);
}

/************************************************/

void settings_change()
{
    int ci;
    char ch[2], c;
    while (1)
    {
        printf("input the NO. your want to change the status: ");
        s_gets(ch, 2);
        ci = ch[0];
        ci -= 48;
        if (ci >= 1 && ci <= j_settings)
        {
            if (sets[ci - 1].status == 1)
                sets[ci - 1].status = 0;
            else
                sets[ci - 1].status = 1;
            break;
        }
        else
        {
            puts("# Wrong Setting NO. #\n");
            printf("Would you like to quit?(Y/N): ");
            s_gets(ch, 2);
            c = ch[0];
            if (c == 'Y' || c == 'y')
                break;
        }
    }

    //printf("%d", ci);
}

/************************************************/

void settings_frpintf()
{
    FILE *fp;
    fp = fopen("settings.txt", "w");
    for (int i = 0; i < j_settings; i++)
        fprintf(fp, "%s %d\n", sets[i].name, sets[i].status);
    fclose(fp);
}

/************************************************/

void baglist_get(int n)
{
    FILE *fp;
    int i;
    fp = fopen("all_10.txt", "r");
    j_all = enter_counter(fp);
    for (int i = 0; i < j_all; i++)
        fscanf(fp, "%s %s %s %s", all[i].item_name, all[i].property.ID, all[i].property.type, all[i].property.site);
    fclose(fp);
	char own_savepath[30];
	sprintf(own_savepath, "saves/save%d/Inventory.txt",n);
    if ((fp = fopen(own_savepath, "r")) == NULL){
		puts("can't find the file");
		exit(0);
	}
    j_capacity = enter_counter(fp);
    for (i = 0; i < j_capacity; i++)
    {
        fscanf(fp, "%s %d %s", capacity[i].item_name, &capacity[i].amount, capacity[i].property.ID);
        fscanf(fp, "%s %s", capacity[i].property.type, capacity[i].property.site);
    }
    fclose(fp);
}

/************************************************/

void baglist_fprint(int n)
{
    FILE *fp;
	char own_savepath[30];
	sprintf(own_savepath, "saves/save%d/Inventory.txt",n);
    fp = fopen(own_savepath, "w");
    for (int i = 0; i < j_capacity; i++)
    {
        fprintf(fp, "%s %d ", capacity[i].item_name, capacity[i].amount);
        fprintf(fp, "%s %s %s\n", capacity[i].property.ID, capacity[i].property.type, capacity[i].property.site);
    }
    fclose(fp);
}

/************************************************/

void baglist_view() //格式化输出
{
    int i, max, relmax, j;
    max = strlen(capacity[0].item_name);
    for (i = 1; i < j_capacity; i++)
    {
        if (strlen(capacity[i].item_name) > max)
            max = strlen(capacity[i].item_name);
    }
    printf("bag:\n");
    printf("\tNO.\tItems");
    for (j = 0; j < max - (strlen("Items") - 5); j++)
        printf(" ");
    printf("Amount");

    if (show_advanced_setting == true)
        printf("\ttype");
    putchar(10);
    for (i = 0; i < j_capacity; i++)
    {
        relmax = max - strlen(capacity[i].item_name);
        printf("\t%d\t%s", i + 1, capacity[i].item_name);
        for (j = 0; j < relmax + strlen("Items"); j++) //这里 +5 是因为 Items 的长度为 5
            printf(" ");
        printf("%d", capacity[i].amount);
        if (show_advanced_setting == true)
            printf("\t\t%s", capacity[i].property.type);
        putchar(10);
    }
}

/************************************************/

void baglist_add()
{
    int k, i, ran;
    char obtain[20];
    srand((unsigned)time(NULL));
    ran = rand() % j_all;
    strcpy(obtain, all[ran].item_name);
    printf("the item you obtained: %s\n", obtain);
    for (i = 0; i < j_all; i++)
        if (strcmp(all[i].item_name, obtain) == 0)
            break;
    k = i;
    bool find = true;
    ran = rand() % 10 + 1;
    for (i = 0; i < j_capacity; i++)
    {
        if (strcmp(capacity[i].item_name, obtain) == 0)
        {
            capacity[i].amount += ran;
            find = false;
            break;
        }
    }
    if (find) //adding new item and its properties
    {
        strcpy(capacity[j_capacity].item_name, obtain);
        capacity[j_capacity].amount = ran;
        strcpy(capacity[j_capacity].property.ID, all[k].property.ID);
        strcpy(capacity[j_capacity].property.type, all[k].property.type);
        strcpy(capacity[j_capacity].property.site, all[k].property.site);
        j_capacity++;
    }
    printf("%s has been added\n", obtain);
}

/************************************************/

int baglist_char_to_int(char *operate_NOc)
{
    //要求输入数字，但用户就是不输入数字来捣乱的解决方法
    int operate_NOi[3], operate_NO = 0, j;
    int len = strlen(operate_NOc);
    int len1 = len - 1;
    for (int i = 0; i < len; i++)
    {
        operate_NOi[i] = operate_NOc[i];
        operate_NOi[i] -= 48;      //1的ASCII码是49，所以减掉48变成1。
        for (j = len1; j > 0; j--) //还原各个位上的数字
            operate_NOi[i] *= 10;
        len1--;
        operate_NO += operate_NOi[i];
    }
    return operate_NO;
}

/************************************************/

void baglist_delete()
{
    char operate_NOc[4], c;
    int operate_NO, i;
    
        operate_NO = 0;
        printf("input the NO. of the item: ");
        operate_NO = baglist_char_to_int(s_gets(operate_NOc, 4));
        if (j_capacity >= operate_NO && operate_NO > 0)
        {
            printf("#do you want to delete this item? #(Y/N): ");
            c = differ_platform_getchar();
            if (c == 'y' || c == 'Y')
            {
                puts("# starting deleting #");
                if (operate_NO != j_capacity)
                    for (i = operate_NO; i < j_capacity; i++) //2019/10/22/23：25留：记得测试只调换capacity的情况能不能正常运行
                    {
                        capacity[i - 1] = capacity[i]; //2019/10/23/6:59 证明确实是可以的
                    }
                else
                    ;
                j_capacity--;
                puts("# the item has been deleted #");
            }
        }
        else{
            printf("# Item not found #(press Enter to continue)");
			getchar();
		}
    
}

/************************************************/

void baglist_exchange()
{
    char operate_NOc[4], c, ch[2];
    int operate_NO1, operate_NO2;
    char temp_item_name[20], temp_ID[22], temp_type[20], temp_site[20];
    int temp_amount;
    while (1)
    {
        printf("input the NO. of an item: ");
        operate_NO1 = baglist_char_to_int(s_gets(operate_NOc, 4));
        printf("input the NO. of another item: ");
        operate_NO2 = baglist_char_to_int(s_gets(operate_NOc, 4));
        if (j_capacity >= operate_NO1 && j_capacity >= operate_NO2 && operate_NO1 > 0 && operate_NO1 > 0)
        {
            puts("# starting exchanging #");
            if (operate_NO1 != operate_NO2)
            {
                temp = capacity[operate_NO1 - 1];
                capacity[operate_NO1 - 1] = capacity[operate_NO2 - 1];
                capacity[operate_NO2 - 1] = temp;
            }
            else
                ;
            puts("# the items have been exchanged #");
        }
        else
        {
            puts("# not found #");
            printf("# would you like to exit? # (Y/N): ");
            s_gets(ch, 2);
            c = ch[0];
            if (c == 'y' || c == 'Y')
                break;
            else
                continue;
        }
        break;
    }
}

/************************************************/

void baglist_choose()
{
    char c;
    bool t1 = true, t2 = true;
    while (t1)
    {
		if(t2)
		{
			puts("******************************************");
			puts("----Bag Menu----");
    		puts(" a) delete an item");
    		puts(" b) exchange position");
			puts(" c) show Bag's Item");
			puts(" p) print Bag Menu");
    		puts(" q) quit");
    		puts("******************************************");
		}
		t2 = false;
		printf("enter your choice: ");
        c = differ_platform_getchar();
        switch (c)
        {
        case 'a':
            baglist_delete();
            break;
        case 'b':
            baglist_exchange();
            break;
		case 'c':
			baglist_view();
			break;
		case 'p':
			t2 = true;
			break;
        case 'q':
            t1 = false;
            break;
        default:
            printf("# invalid input #(press enter to continue)");getchar();
        }
		putchar(10);
    }
}

/************************************************/

void craft_table()
{

}


/************************************************/
//效果
void transition_effect(float n)
{
    for (int i = 0; i < 5; i++)
    {
        printf(".");
#ifdef WIN32
	Sleep(1000*n);
#else
	sleep(n);
#endif
    }
    printf("\r");
}
/************************************************/
int attack(int blood, int damage, int critical_strike, bool d_w, int duck)
{
    //system("COLOR 74");
    int cs, i = 0;
    srand((unsigned)time(NULL));
    cs = rand() % 10 + 1;
    if (cs <= critical_strike)
    {
        puts("# 触发暴击 #");
        damage = damage * 1.5;
    }
    if (duck == 1)
    {
        puts("effecitve duck, no loss of blood!");
        damage = 0;
    }
    if (duck == 2)
        damage = damage * 2;
    blood -= damage;

    if (!d_w)
        i++;
    transition_effect(0.2);
    printf("%s使用攻击造成 %d 点伤害\n", context_current[i], damage);
    transition_effect(0.2);
    printf("%s的血量剩余 %d 点\n", context_current[!i], blood);
    putchar(10);
    return blood;
}
/************************************************/
int duck(int duck_prob, bool d_w)
{
    int dp;
    srand((unsigned)time(NULL));
    dp = rand() % 10 + 1;
    transition_effect(0.2);
    if (d_w)
        puts("你使用闪避");
    else
        puts("敌方使用闪避");
    transition_effect(0.2);
    if (dp <= duck_prob)
    {
        puts("闪避召唤成功，下个回合不会受到伤害!\n");
        return 1;
    }
    else
    {
        puts("闪避召唤失败，下个回合将受到攻击伤害*2!\n");
        return 2;
    }
}
/************************************************/
//1240
int power_up(int blood, int critical_strike, int duck_prob, int heal_percent, bool d_w)
{
    int i = 0;
    blood = blood - 5;
    transition_effect(0.2);
    if (!d_w)
        i++;
    printf("%s的作战强度全方面提升。敌方的生命值 -5 点，暴击率 +10%%，闪避率 +10%%，治疗百分比 +4%%\n", context_current[i]);
    transition_effect(0.2);
    printf("%s生命值剩余 %d 点，暴击率 %d%%，闪避率 %d%%，治疗百分比 %d%% \n", context_current[i], blood, critical_strike * 10, duck_prob * 10, heal_percent * 4);
    putchar(10);
    return blood;
}
/************************************************/
int power_down(int bld, int blood, int critical_strike, int duck_prob, int heal_percent, bool d_w)
{
    int i = 0;
    blood = blood + 5;
    if (blood > bld)
    {
        transition_effect(0.2);
        puts("超出部分全部作废\n");
        blood = bld;
    }
    transition_effect(0.2);
    if (!d_w)
        i++;
    printf("%s的作战强度全方面下降。你的生命值 +5 点，暴击率 -10%%，闪避率 -10%%，治疗百分比 -4%%\n", context_current[i]);
    transition_effect(2);
    printf("%s的生命值剩余 %d 点，暴击率 %d%%，闪避率 %d%%，治疗百分比 %d%% \n", context_current[i], blood, critical_strike * 10, duck_prob * 10, heal_percent * 4);
    putchar(10);
    return blood;
}
/************************************************/
int heal(int bld, int blood, float heal_percent, int heal_count, bool d_w)
{
    transition_effect(0.2);
    if (heal_count >= 0)
    {
        int i = 0;
        int healing = (bld - blood) * (heal_percent / 25);
        blood = healing + blood;
        if (!d_w)
            i++;
        printf("%s使用治疗，恢复 %d 点血量\n", context_current[i], healing);
        transition_effect(0.2);
        printf("%s的血量剩余 %d 点\n\n", context_current[i], blood);
        printf("heal 的使用次数剩余 %d 次", heal_count);
    }
    else
        puts("heal 的次数已用尽!");
    putchar(10);
    return blood;
}
/************************************************/
void fight(int n)
{
    //system("COLOR a0");

    int enemy_blood, enemy_damage, chara_blood, chara_damage, ene_bld, cha_bld;
    enemy_blood = ene_bld = 36;
    enemy_damage = 2;
    chara_blood = cha_bld = 100;
    chara_damage = 6;
    int critical_strike = 1, duck_prob = 1; //最大25点
    int enemy_critical = 1, enemy_duck = 1; //最大25点
    float heal_percent = 12.0, enemy_heal = 12.0;
    char filename[30], c;
    int du_ck, enemy_du_ck;                                                            //0表示什么都不是，1表示成功，2表示失败(0:nothing; 1:success; 2:failed)
    int chara_duck_count = 0, chara_duck_count_success = 0, chara_duck_count_fail = 0; //记录召唤了多少次闪避(record how many duck has been summoned)
    int enemy_duck_count = 0, enemy_duck_count_success = 0, enemy_duck_count_fail = 0; //记录召唤了多少次闪避(record how many duck has been summoned)
    int chara_heal_count = 2, enemy_heal_count = 2;
    bool character = true, enemy = false;
    bool fight_vd;
    FILE *fp;
    sprintf(filename, "saves/save%d/explanation.txt", n);
    puts("\n************************ FIGHT ************************\n");
    if (access(filename, 0) == -1)
    {
        puts("\t行动说明:\n\t一回合只能进行一次行动");
        puts("\tenemy 有和你一样的行动选项");
        puts("\tattack可对目标进行一次攻击(有几率触发暴击,暴击伤害=普通伤害*150%).");
        puts("\tduck可对目标的下一次攻击进行闪避判定。如果判定生效你免疫下一次受到的攻击伤害; 如果判定无效且敌人发动攻击,你将受到攻击伤害*200%.");
        puts("\theal可恢复已损失生命值的50%，只能使用2次，但当duck的判定的生效次数为双数时，heal的使用次数恢复为2次");
        puts("\t执行一次power up 当前血量 -5 点，攻击伤害 +3 点，暴击的几率 +4%，闪避成功几率 +4%，治疗 +4%");
        puts("\t执行一次power down 当前血量 +5 点，攻击伤害 -3 点，暴击的几率 -4%，闪避成功几率 -4%，治疗 -4%");
        putchar(10);
        while (1)
        {
            transition_effect(0.2);
            puts("a.了解了 \t b.了解了且下次不再提醒");
            printf("输入你的选择: ");
            c = differ_platform_getchar();
            putchar(10);
            if (c == 'a' || c == 'A')
                ;
            else if (c == 'b' || c == 'B')
                fp = fopen(filename, "w");
            else
            {
                puts("无效字符\n");
                continue;
            }
            break;
        }
    }
    putchar(10);
    int ene_act; //取一个随机数，此随机数决定NPC的行为，详细请看第230行。避免while循环内多次定义ene_act所以把定义放在这里
    while (1)
    {
        du_ck = 0; //每一回合的开头重置为0      //0表示什么都不是，1表示成功，2表示失败
        //character action
        puts("\ta.attack \t b.duck");
        puts("\tc.power up \t d.power down");
        puts("\te.heal");


        printf("choose an action you want: ");
        c = differ_platform_getchar();
        putchar(10);
        switch (c)
        {
        case 'a':
            enemy_blood = attack(enemy_blood, chara_damage, critical_strike, character, enemy_du_ck);
            break;
        case 'b':
            du_ck = duck(duck_prob, character);
            break;
        case 'c':
            critical_strike++;
            duck_prob++;
            heal_percent++;
            chara_blood = power_up(chara_blood, critical_strike, duck_prob, heal_percent, character);
            break;
        case 'd':
            critical_strike--;
            duck_prob--;
            heal_percent--;
            chara_blood = power_down(cha_bld, chara_blood, critical_strike, duck_prob, heal_percent, character);
            break;
        case 'e':
            chara_heal_count--;
            chara_blood = heal(cha_bld, chara_blood, heal_percent, chara_heal_count, character);
            break; //heal
        default:
            puts("# 无效字符 #");
            continue;
        }
        if (enemy_blood <= 0)
        {
            puts("# Victory #");
            fight_vd = true;
            break;
        }
        if (chara_blood <= 0)
        {
            puts("# Defeat #");
            fight_vd = false;
            break;
        }
        if (du_ck == 1 || du_ck == 2)
        {
            chara_duck_count++;
            if (du_ck == 1)
                chara_duck_count_success++;
            else
                chara_duck_count_fail++;
        }
        if (chara_duck_count_success % 2 == 0 && chara_duck_count_success != 0)
        {
            chara_heal_count = 2;
            printf("# heal使用次数回复为两次 #\n");
        }

        //enemy action
        enemy_du_ck = 0; //每一回合的开头重置为0      //0表示什么都不是，1表示成功，2表示失败
        printf("enemy turn\n");
        srand((unsigned)time(NULL));
        ene_act = rand() % 5 + 1;
        switch (ene_act)
        {
        case 1:
            chara_blood = attack(chara_blood, enemy_damage, enemy_critical, enemy, du_ck);
            break;
        case 2:
            enemy_du_ck = duck(enemy_duck, enemy);
            break;
        case 3:
            enemy_critical++;
            enemy_duck++;
            enemy_heal++;
            enemy_blood = power_up(enemy_blood, enemy_critical, enemy_duck, enemy_heal, enemy);
            break;
        case 4:
            enemy_critical--;
            enemy_duck--;
            enemy_heal--;
            enemy_blood = power_down(ene_bld, enemy_blood, enemy_critical, enemy_duck, enemy_heal, enemy);
            break;
        case 5:
            enemy_heal_count--;
            enemy_blood = heal(ene_bld, enemy_blood, enemy_heal, enemy_heal_count, enemy);
            break;
        default:
            break;
        }
        if (chara_blood <= 0)
        {
            puts("# Defeat #");
            fight_vd = false;
            break;
        }
        if (enemy_blood <= 0)
        {
            puts("# Victory #");
            fight_vd = true;
            break;
        }
        if (enemy_du_ck == 1 || enemy_du_ck == 2)
        {
            enemy_duck_count++;
            if (enemy_du_ck == 1)
                enemy_duck_count_success++;
            else
                enemy_duck_count_fail++;
        }

        if (enemy_duck_count_success % 2 == 0 && enemy_duck_count_success != 0)
        {
            enemy_heal_count = 2;
            printf("# heal使用次数回复为两次 #\n");
        }
    }
    printf("\t\tduck_count\tduck_count_success\tduck_count_fail\n");
    printf("Chara\t\t%d\t\t%d\t\t\t%d\n", chara_duck_count, chara_duck_count_success, chara_duck_count_fail);
    printf("Enemy\t\t%d\t\t%d\t\t\t%d\n", enemy_duck_count, enemy_duck_count_success, enemy_duck_count_fail);
    if (fight_vd)
    {
        printf("战利品:\n");
        baglist_add();
        baglist_fprint(n);
    }
}

/************************************************/

int *test_for(int *pos, FILE *fp1, int n)
{
    int x, y, i;
    x = pos[0];
    y = pos[1];

    if (x == 0 || y == 0 || x == 49 || y == 49)
    {
        for (i = 0; i < 3; i++)
        {
            printf("## PAD: 您正处于边界地带(你感觉到恐惧爬上了你的脊背)... ##");
#ifdef WIN32
	Sleep(100);
#else
	sleep(0.1);
#endif
            printf("\r");
            printf("\t\t\t\t\t\t");
#ifdef WIN32
	Sleep(100);
#else
	sleep(0.1);
#endif
            printf("\r");
        }
        printf("## PAD: 您正处于边界地带(你感觉到恐惧爬上了你的脊背)... ##\n");
    }

    else if (x < 0 || y < 0 || x > 49 || y > 49)
    {
        for (i = 0; i < 3; i++)
        {
            printf("## PAD: 警告!无法再往此方向前行 ##");
#ifdef WIN32
	Sleep(600);
#else
	sleep(0.6);
#endif
            //Sleep(600);
            printf("\r");
            printf("\t\t\t\t\t\t");
            //printf("                                 ");
            //Sleep(600);
#ifdef WIN32
	Sleep(600);
#else
	sleep(0.6);
#endif
            printf("\r");
        }
        printf("## PAD: 警告!无法再往此方向前行 ##\n");
        if (x < 0)
            x = 0;
        if (y < 0)
            y = 0;
        if (x > 49)
            x = 49;
        if (y > 49)
            y = 49;
    }
    else
        ;
    bool xy = false;
    int pos1[2][10];
    int r = 0, m, k[10];
    for (int i = 0; i < 2; i++)
        for (int j = 0; j < 10; j++)
        {
            fscanf(fp1, "%d", &pos1[i][j]);
            if (i == 0)
            {
                if (x == pos1[i][j])
                {
                    k[r] = j;
                    r++;
                }
            }
            else
            {
                for (m = 0; m < r; m++)
                    if (y == pos1[i][k[m]])
                        xy = true;
            }
        }
    rewind(fp1);
    if (xy)
    {
        puts("fight\n");
        fight(n);
    }
    pos[0] = x;
    pos[1] = y;
    return pos;
}

/************************************************/

void manipulate(int n)
{
	char savepath[30], savefile_cp[30], savefile_yp[30], savefile_hp[30];

    FILE *fp, *fp1, *fp2;
	
    sprintf(savefile_cp, "saves/save%d/chara_pos.txt", n);
    sprintf(savefile_yp, "saves/save%d/yxt_pos.txt", n);
    sprintf(savefile_hp, "saves/save%d/home_pos.txt",n);

    fp = fopen(savefile_cp, "r");
    fp1 = fopen(savefile_yp, "r");
    fp2 = fopen(savefile_hp, "r");

    int sum;
    int pos[2], home_pos[2];
    int *pos1;
    for (int i = 0; i < 2; i++)
    {
        fscanf(fp, "%d", &pos[i]);
        fscanf(fp2, "%d", &home_pos[i]);
    }
    fclose(fp2);
    bool p = false;
    char c;
    //, p1 = true
    while (1)
    {
        putchar(10);
        puts("----Control Panel----");
        puts("    w 向上走");
		puts(" a 向左走 d 向右走");
        puts("    s 向下走");
        puts(" e 背包");
		puts(" w 工作台");
        puts(" i 查看设置");
        puts(" o 更改设置");
        puts(" q 返回主界面\n");
        printf("家的位置( %d,%d )\n", home_pos[0], home_pos[1]);
        printf("当前位置( %d,%d )\n", pos[0], pos[1]);
        printf("往哪儿方向走呢: ");

        c = differ_platform_getchar();
        putchar(10);
        switch (c)
        {
        case 'w':
            pos[1]++;
            break;
        case 's':
            pos[1]--;
            break;
			case 'a':
            pos[0]--;
            break;
        case 'd':
            pos[0]++;
            break;
        case 'e':
            baglist_choose();
            break;
        case 'i':
            settings_view();
            break;
        case 'o':
            settings_change();
            break;
        case 'q':
            p = true;
			break;
		default: printf("# No such choice #"); getchar();
        }
        if (p)
        {
            fclose(fp);
            fclose(fp1);
            fp = fopen(savefile_cp, "w");
            for (int i = 0; i < 2; i++)
                fprintf(fp, "%5d", pos[i]);
            fprintf(fp, "\n");
            fclose(fp);
            break;
        }
        pos1 = test_for(pos, fp1, n);
        pos[0] = pos1[0];
        pos[1] = pos1[1];
        //Sleep(300);
    }
}

/************************************************/

void map_generater(FILE *fp, FILE *fp1, FILE *fp2)
{
    srand((unsigned)time(NULL));
    fprintf(fp, "%d %d", rand() % 10, rand() % 10);  //character position
    fprintf(fp2, "%d %d", rand() % 20, rand() % 20); //home position
    for (int i = 0; i < 2; i++)
    {
        for (int j = 0; j < 10; j++)
            fprintf(fp1, "%3d", rand() % 49);
        fprintf(fp1, "\n");
    }
}

/************************************************/

void plot(int n)
{
    putchar(10);
    /*for(int i=0;i<2;i++)
    {
        if(i==0)
            puts("女娲正在补天，精卫正在填海，全世界都在努力加载地图");
        if(i==1)
            puts("正在把玩家随机抛到坑坑洼洼的地上");
        for(int j=0; j<20; j++)
        {
            Sleep(300);
            printf(".");
        }
        putchar(10);
        putchar(10);
    }                  //拖时间（弄成真的像在加载地图)
    */
    baglist_get(n);
    settings_get();
    putchar(10);
    /*
    puts("飞船: 警报，警报，受不明引力影响，飞船推进器受损，即将在附近行星迫降!!");
    puts("黑屏 黑屏 黑屏 黑屏");
    puts("飞船：船体受损严重，仅有太阳能和工作台可正常使用.");
    */
    for (int i = 0; i < 5; i++)
        puts("\n# 没有剧情 根据提示 瞎玩就行 #");
    putchar(10);
    manipulate(n);
}

/************************************************/

void menu_choose()
{
    putchar(10);
    puts("----Main Menu----");
    puts(" a 开始游戏");               //cotext3.
    puts(" s 新游戏");                 //context4.
    puts(" d 查看各个存档的各项属性"); //context5.
    puts(" q 退出");                   //context6.
}

/************************************************/

void choose_a()
{
    putchar(10);
    if (access("saves", 0) == -1)
    {
        puts("\n# 你还没有开启过任何存档 #\n"); //context9.
        printf("# press Enter to continue #");  //context10.
        getchar();
    }
    else
    {
        int t[3] = {1, 1, 1};
		char savepath[30];
        int i;

        for (i = 0; i < 3; i++)
        {
            sprintf(savepath, "saves/save%d/",i + 1);
            if (access(savepath, 0) == 0)
                printf(" 存档位%d:可进入(键入%d)\n", i + 1, i + 1);
            else
            {
                printf(" 存档位%d:空\n", i + 1);
                t[i] = 0;
            }
            savepath[0] = '\0';
        }
        printf("选择你想进入的存档位(输入 q 回到主菜单): "); //cotext17.
        char c;
		c = differ_platform_getchar();
        putchar(10);
		//printf("%d %d %d\n", t[0],t[1],t[2]);
        if (!t[c - 49]) 
		/* 
			why minus 49: because '2'is 50, 50 - 49 = 1, t[1] means the second element.
		*/
        {
			puts("called if function\n");
            puts("# 进入存档失败：没有在主菜单创建存档 或是 输入了不存在的存档 #\n"); //context18.
            c = 'q';
        }
        switch (c)
        {
        case '1':
            plot(1); //cotext23. -
            break;
        case '2':
            plot(2);
            break;
        case '3':
            plot(3);
            break;
        case 'q':
            putchar(10);
            break;
        default:
            puts("# Worng Choice!! #"); //context19.
        }
    }
}

/************************************************/

void choose_s() //建立地图元素
{
    FILE *fp, *fp1, *fp2, *fp3;
	char savepath[30], savefile_cp[30], savefile_yp[30], savefile_hp[30], savefile_inv[30];
    if (access("saves", 0) == -1) //create "saves/" or "/home/user/.../saves" if didn't create before
	{
#ifdef WIN32
	mkdir("saves/");
#else 		
	mkdir("saves/",0777); //return 0 for seccess , return -1 for failure
#endif
	}
    int i = 1;
    while (1)
    {
		int i_mkdir;
		sprintf(savepath, "saves/save%d/",i);
        if (access(savepath, 0) == -1)
        {
            sprintf(savefile_cp, "%schara_pos.txt", savepath);
            sprintf(savefile_yp, "%syxt_pos.txt", savepath);
            sprintf(savefile_hp, "%shome_pos.txt", savepath);
			sprintf(savefile_inv, "%sInventory.txt",savepath);
            //mkdir(savepath); //create each save
#ifdef WIN32
	i_mkdir = mkdir(savepath);
#else 		
	i_mkdir = mkdir(savepath,0777);
#endif
            if(i_mkdir == 0)
			{
				fp = fopen(savefile_cp, "w");
            	fp1 = fopen(savefile_yp, "w");
            	fp2 = fopen(savefile_hp, "w");
				fp3 = fopen(savefile_inv, "w");
            	map_generater(fp, fp1, fp2);
            	fclose(fp);
            	fclose(fp1);
            	fclose(fp2);
				fclose(fp3);
            	printf("# 已创建存档%d #\n", i); //context20.
				printf("savepath_cpy: %s\n",savepath);
				savepath[0] = '\0';// clear the string
				printf("savepath_cpy: %s\n",savepath);
            	break;
			}
			else
			{
				printf("# fail to create game saves #\n");
				break;
			}
        }
        else
        {
            i++;
            if (i > 3)
            {
                printf("当前存档数量达到上限.\n");     //context21.
                printf("# press Enter to continue #"); //context22.
                getchar();
                break;
            }
            //continue;
        }
    }
    putchar(10);
}

/************************************************/

void choose_d()
{
    int i;
    FILE *fp;
    char filename[30];
    for (i = 0; i < 3; i++)
    {
        sprintf(filename, "saves/save%d/chara_pos.txt", i);
        fp = fopen(filename, "r");
        printf("存档%d\n", i);
        printf("money: ￥%d\n", chara.money);
        putchar(10);
      	transition_effect(0.1);
		putchar(10);
        putchar(10);
    }
}

/************************************************/

void lan_context()
{
    FILE *fp;
    fp = fopen("context.txt", "r");
    char c;
    // 提取阶段
    int i = 0, j = 0, p = 0;
    while ((c = fgetc(fp)) != EOF)
    {
        p++;
        if (p <= 3)
            continue; //去掉txt中的句子编号
        context[i][j] = c;
        if (c == '\n')
        {
            context[i][j] = '\0';
            i++;
            j = -1;
            p = 0;
        }
        j++;
    }
    fclose(fp);
}

/************************************************/

void menu_main()
{
    //lan_context();
    putchar(10);
    puts("*************************************");
    puts("*** Designed by Derivative_Marmot ***");
    puts("***  Copyright Derivative_Marmot  ***");
    puts("*************************************");
    puts("\n\n");
    puts("      MM      MM           A       RRRRRRRRR       MM      MM         OOOOOO     TTTTTTTTT            RRRRRRRRR  EEEEEEEE     CCCCCCCC     OOOOOO     NN      N      ");
    puts("     M  M    M  M         A A      R       R      M  M    M  M       O      O        T                R       R  E          CC        C   O      O    N  N    N      ");
    puts("    M    M  M    M       A   A     RRRRRRRRR     M    M  M    M     O        O       T                RRRRRRRRR  EEEEEE    CC            O        O   N   N   N      ");
    puts("   M      MM      M     AAAAAAA    R     R      M      MM      M    O        O       T                R     R    EEEEEE    CC            O        O   N    N  N      ");
    puts("  M                M   A       A   R      R    M                M    O      O        T                R      R   E          CC        C   O      O    N     N N      ");
    puts(" M                  M A         A  R       R  M                  M    OOOOOO         T                R       R  EEEEEEEE     CCCCCCCC     OOOOOO     N      NN      ");
    puts("\n\n");
    puts("# 如果上方出现乱七八糟的英文字幕请将窗口最大化(也许就能看清) #"); //conext1.
	printf("# You are running this program using %s #",OS);

    //printf("context = %s\n", context[0]);
    puts("#空格用'.'或'_'代替#\n"); //cotext2.
    //printf("context = %s\n", context[1]);
    //printf("context = %s\n", context[2]);
    while (1)
    {
        menu_choose();         //cotext3.- 6.
        printf("做个选择吧:"); //context7.
        /*
        char ch[2], c;
        s_gets(ch, 2);
        c = ch[0];
        putchar(10);
        switch (c)
        {
        case 'a':
            choose_a(); //context9. - 19.
            break;
        case 's':
            choose_s(); //context20. - 22.
            break;
        case 'd':
            choose_d();
            break;
        case 'q':
            exit(0);
        default:
            puts("\n# !!重新输入哦!! #"); //context8.
        }
        */
        char c;
        c = differ_platform_getchar();
        putchar(10);
        putchar(10);
        if(c == 'a')
            choose_a();
        else if(c == 's')
            choose_s();
        else if(c == 'd')
            choose_d();
        else
            break;
    }
}

/************************************************/

int main(void)
{
    menu_main();
    printf("\n");
    system("pause");
    return 0;
}
